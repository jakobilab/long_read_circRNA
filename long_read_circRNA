#!/usr/bin/env python3

import argparse
import sys
import os
from pathlib import Path
import subprocess

class ArgumentCaller:
    
    __version__ = 3.0
    
    def __init__(self):
        print(
r"""
  _                    ___             _      _        ___ _  _   _   
 | |   ___ _ _  __ _  | _ \___ __ _ __| |  __(_)_ _ __| _ \ \| | /_\  
 | |__/ _ \ ' \/ _` | |   / -_) _` / _` | / _| | '_/ _|   / .` |/ _ \ 
 |____\___/_||_\__, | |_|_\___\__,_\__,_| \__|_|_| \__|_|_\_|\_/_/ \_\ 
               |___/                                                    

Version: v{}

Original code by Morten T Ven√∏ <morten.veno@omiics.com>

Adapted for circtools integration by Tobias Jakobi <tjakobi@arizona.edu>
""".format(self.__version__))

        
        parser = argparse.ArgumentParser(
            description="Description: CircRNA detection in nanopore data",
            usage='''%(prog)s <command> [args]
            
                    Available sub-commands:
                        run         Main command for finding circRNAs in long read nanopore data
                        download    Download any required data for references and prepare
                        check       Check if all of the required software is available
                    ''')

        parser.add_argument('command', help='Specify which subcommand should be used')
        args = parser.parse_args(sys.argv[1:2])
        command = args.command

        # Correct for inputs with - in the name
        command = command.replace("-","_")
        if not hasattr(self, command):
            print("Unrecognized command")
            parser.print_help()
            sys.exit(1)
        getattr(self, command)()
        
    def run(self):
        parser = argparse.ArgumentParser(
            description="Run the program for detecting circRNAs in Oxford Nanopore data",
            prog="long_read_circRNA"
        )

        parser.add_argument(
            'sample',
            help="Provide a sample input .fq.gz file that should be processed.")
        parser.add_argument(
            '-r',
            '--reference-path',
            default="./data",
            help="Provide a path for where the reference data is located. Default is './data'.")
        parser.add_argument(
            '-g',
            '--genome',
            choices=['hg19', 'hg38', 'mm9', 'mm10'],
            help="Required. Select which genome build the sample that is from, and specify which genome reference files should be used.",
            required=True)
        parser.add_argument(
            '-s',
            '--script-path',
            default="~/long_read_circRNA/scripts",
            help="Specify where the long_read_circRNA scripts are located. Default: '~/long_read_circRNA/scripts'.")
        parser.add_argument(
            '-o',
            '--output-path',
            default=".",
            help="Provide a path for where the output should be saved. Default is the current directory.")
        parser.add_argument(
            '-t',
            '--threads',
            default=4,
            type=int,
            help="Number of threads for parallel steps. Default: 4.")
        parser.add_argument(
            '-d',
            '--dry-run',
            action="store_true",
            help="Perform all of the input checks without starting the detection scripts")
        parser.add_argument(
            '-k',
            '--keep-temp',
            action="store_true",
            help="Keep all of the temporary files.")
        
        args = parser.parse_args(sys.argv[2:])
    
        self.check_installation(args=False)
    
        reference_path = args.reference_path
        genome = args.genome
        threads = args.threads
        
        # Check if reference_path exists
        if not os.path.exists(reference_path):
            print("Error: '{}' does not exists! Please make sure that the path is written correctly".format(reference_path))
            exit(-1)
        
        # Check if reference_path is a directory:
        if not os.path.isdir(reference_path):
            print("Error: '{}' is not a directory! Please provide a directory that contains the reference data.".format(reference_path))
            exit(-1)

        # Check if reference_path contains genome in the end
        if os.path.basename(reference_path)==genome:
            print("Error: Looks like you have provided the direct path to the genome directory '{}'. Please simply provide data directory '{}'.".format(
                reference_path, os.path.dirname(reference_path)
            ))
            exit(-1)

        # Check if reference_path + genome exists
        if not os.path.exists(os.path.join(reference_path, genome)):
            print("Error: The genome build {} in the directory {} does not exist!".format(genome, reference_path))
            print("Note: You might need to download genome data first using the download command.")
            exit(-1)

        # Check if sample exists
        if not os.path.exists(args.sample):
            print("Error: Sample file '{}' does not exist!".format(args.sample))
            exit(-1)

        # Check if sample ends with ".fq.gz"
        if not args.sample.endswith(".fq.gz"):
            print("Error: Sample file '{}' does not end with '.fq.gz'".format(args.sample))
            exit(-1)

        # Prepare sample_path and sample_name
        reference_path = str(Path(reference_path).resolve())
        sample_path = str(Path(os.path.dirname(args.sample)).resolve())
        sample_name = os.path.basename(args.sample).replace('.fq.gz', '')
        
        script_path = str(Path(os.path.expanduser(args.script_path)).resolve())
        output_path = str(Path(args.output_path).resolve())
        
        # Check if the script-path exists
        if not os.path.exists(script_path):
            print("Error: The script path '{}' does not exists! Please point to the location of the scripts directory in the long_read_circRNA path using --script-path".format(script_path))
            exit(-1)

        # Check if the required scripts are in the script script-path
        target_scripts = ["blat_nanopore_v5.5.sh", "novel_exons_and_alternative_usage_v7.0.sh"]
        for target_script in target_scripts:
            if not os.path.exists(os.path.join(script_path, target_script)):
                print("Error: '{}' script is not found in the script path '{}'. Are you sure the provided script-path is correct?".format(target_script, script_path))
                exit(-1)

        # Check if the output path exists
        if not os.path.exists(output_path):
            print("Error: Output_path '{}' does not exist!".format(output_path))
            exit(-1)

        output_path = os.path.join(output_path, sample_name)
        
        print("Starting process with the following settings")
        print("\tSample name: {}".format(sample_name))
        print("\tReference path: {}".format(reference_path))
        print("\tSample path: {}".format(sample_path))
        print("\tGenome build: {}".format(genome))
        print("\tScript-path: {}".format(script_path))
        print("\tOutput-path: {}".format(output_path))
        
        original_directory = os.getcwd()
        
        if not args.dry_run:
            # Main process for circRNA detection
            print("")
            subprocess.run(["bash", os.path.join(script_path, "blat_nanopore_v6.0.sh"),
                            sample_path, sample_name, genome, reference_path, script_path, output_path, str(threads)])
            print("")
        
            print("circRNA detection has finished")
            print("Starting the novel exon and alternative usage script")
        
            os.chdir(original_directory)
            
            keep_check = {True: "yes", False: "no"}
            
            keep_temp = keep_check[args.keep_temp]
        
            print("")
            subprocess.run(["bash", os.path.join(script_path, "novel_exons_and_alternative_usage_v8.0.sh"),
                        sample_name, genome, reference_path, script_path, output_path, keep_temp, str(threads)])
            print("")
        
            print("Long_read_circRNA has finished!")
        else:
            print("Dry run is complete")

    
    def check_installation(self, args=True):
        if args:
            parser = argparse.ArgumentParser(
                description="Check if environment for running the script is properly setup by checking if all of the required software is available",
                usage="%(prog)s check-installation [args]"
            )
            args = parser.parse_args(sys.argv[2:])
        
        tools = {"bedtools": "bedtools", 
                 "NanoFilt": "NanoFilt -h", 
                 "pblat": "pblat", 
                 "perl": "perl -v",
                 "samtools": "samtools --help"}
        
        failed = False
        warn = False
        
        print()
        
        for tool in tools:
            print("Checking for {}".format(tool))
            try:
                output = subprocess.run(tools[tool].split(" "), stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=5)
                if output.returncode!=0:
                    print("\tThere might be a problem with {}".format(tool))
                    warn = True
            except FileNotFoundError:
                print("\\tUnable to find {}!".format(tool))
                failed = True
            except Exception as e:
                print(e)
        
        if warn:
            print()
            print("WARNING: There might be a problem with some of the software installed")
            print()
        
        if failed:
            print()
            print("ERROR: Some of the required software is missing!")
            print()
            sys.exit(1)
        else:
            print()
            print("All of the expected software requirements are present!")
            print()        
        
if __name__=="__main__":
    ArgumentCaller()
